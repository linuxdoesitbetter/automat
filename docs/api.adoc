== API

Header::
+
[source,c]
----
#include <automat.h>
----

Bibliothek:: libautomat

Linker:: -lautomat

Diese Bibliothek bietet die Möglichkeit, Automaten UML-nah statisch zu
definieren.

[width="50%",options="header,footer"]
|====================
 |Aufzählungen  
 |<<EventType>>
 |<<StateType>>
h|Funktionszeiger
 | <<Action>>
 | <<Condition>>
 | <<Effect>>
 | <<Guard>>
h|Strukturen
 |<<Event>>
h|Methoden
|====================

=== Typen

==== EventType
Definition::
+
[source,c]
-----
typedef enum {
  EVENT_TYPE_BASE = 0,
  EVENT_TYPE_CHANGE,
  EVENT_TYPE_SIGNAL
} EventType;
-----
Beschreibung::
Die Bibliothek unterscheidet zwei Arten von Events. Signal-Events informieren
die Statemachine über das Eintreten von Ereignissen, deren Quelle meist
außerhalb der Statemachine liegt. Beispiele sind Timer-Events, Tastatur- oder
Drehencoder-Events. Signal-Events können zusätzliche Event-spezifische Daten
enthalten. Change-Events überwachen eine auslösende Bedingung. Z. B. wenn eine
Variable einen bestimmten Wertebereich be-, unter- oder überschreitet.


==== StateType
Definition::
+
[source,c]
-----
typedef enum {
  STATE_TYPE_BASE = 0,
  STATE_TYPE_SIMPLE,
  STATE_TYPE_COMPOSITE,
  STATE_TYPE_ENTRY_POINT,
  STATE_TYPE_EXIT_POINT
} StateType;
-----
Beschreibung::
Es wird werden verschiedene Typen von Zuständen unterschieden.
Der Simple-State ist ein -im Sinne dieser Bibliothek- atomarer Zustand. Er
kann Aktivitäten und Transitionen enthalten. Ein Composite-State ist ein
zusammengesetzter Zustand. Er enthält ein oder mehrere Unter-Automaten.
Entry- und Exit-Points sind Pseudozustände die für Transitionen zwischen
Zuständen verschiedener Automaten benötigt werden.


==== Action
Definition::
+
[source,c]
-----
typedef void
(*Action)(
    SignalEvent * t_event,
    void *        t_context );
-----
Beschreibung::
Eine Aktion ist der auzuführende Code einer Aktivität. Das auslösende Event
wird im Parameter `t_event` übergeben und kann in der Aktion ausgewertet oder
verarbeitet werden. Mit dem Parameter `t_context` wird der Kontext des Automaten
übergeben.


==== Condition
Definition::
+
[source,c]
-----
typedef bool
(*Condition)(
    void * t_context );
-----
Beschreibung::
Eine Bedingung ist das Entscheidungskriterium für das Auslösenen eines
Change-Events. Mit dem Parameter `t_context` wird der Kontext des Automaten
übergeben.


==== Effect
Definition::
+
[source,c]
-----
typedef void
(*Effect)(
    SignalEvent * t_event,
    void *        t_context );
-----
Beschreibung::
Ein Effekt ist der optionale Code, der während einer Transition ausgeführt
werden kann. Das auslösende Event wird im Parameter `t_event` übergeben und
kann im Effekt ausgewertet oder verarbeitet werden. Mit dem Parameter
`t_context` wird der Kontext des Automaten übergeben.


==== Guard
Definition::
+
[source,c]
-----
typedef bool
(*Guard)(
    SignalEvent * t_event,
    void *        t_context );
-----
Beschreibung::
Ein Guard ist eine einschränkende Bedingung, mit der eine Transition unterdrückt
werden kann. Das auslösende Event wird im Parameter `t_event` übergeben und
kann im Guard ausgewertet oder verarbeitet werden. Mit dem Parameter `t_context`
wird der Kontext des Automaten übergeben.

==== Event
Definition::
+
[source,c]
----
struct SEvent {
  int    m_id;
};

typedef struct SEvent Event;
----

Beschreibung::
bla

==== Activity
Definiton::
+
[source,c]
----
struct SActivity {
  Event *  m_event;
  Guard    m_guard;
  Action   m_action;
};

typedef struct SActivity Activity;
----

Beschreibung::
+
Mithilfe dieses Typs werden Aktionen in einem Zustand definiert. Aktionen
werden als Reaktion auf ein Event ausgeführt, führen aber im Gegensatz zu
Transitionen nicht zum Verlassen des aktuellen Zustands.
+
Der Member `m_event_id` gibt an, auf welchen Event-Typ reagiert werden soll.
Mit dem Member `m_guard` kann ein Guard hinterlegt werden, mit dem entschieden
werden kann, ob der ActionHandler tatsächlich aufzurufen ist. Wird `m_guard` mit
`NULL` initialisiert, wird der ActionHandler bei jedem Event mit passendem Typ
ausgeführt. Der ActionHandler `m_action_handler` repräsentiert die auszuführende
Funktion.
